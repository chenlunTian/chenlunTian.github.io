<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hello-word</title>
    <url>/posts/de5a874b.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;</code></pre>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo server</code></pre>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo generate</code></pre>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$ hexo deploy</code></pre>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>pcigo-command设置lskypro</title>
    <url>/posts/4ddba583.html</url>
    <content><![CDATA[<h1 id="pcigo-command设置lskypro"><a href="#pcigo-command设置lskypro" class="headerlink" title="pcigo-command设置lskypro"></a>pcigo-command设置lskypro</h1><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><h3 id="1-1-Curl的安装与配置"><a href="#1-1-Curl的安装与配置" class="headerlink" title="1.1 Curl的安装与配置"></a>1.1 Curl的安装与配置</h3><ul>
<li>安装配置Curl<br> <a href="https://curl.se/download.html">Curl 下载地址</a></li>
<li>解压</li>
</ul>
<p> 下载完成后，我解压到了这样一个目录</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">D:\Compile_Tool\curl-8.4.0</code></pre>

<ul>
<li>配置环境变量</li>
</ul>
<p>新建一个环境变量</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">CURL_HOME
D:\Compile_Tool\curl-8.4.0</code></pre>

<p>然后Path中追加这个环境变量即可</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">%CURL_HOME%\bin\</code></pre>

<h3 id="1-2-picgo的安装"><a href="#1-2-picgo的安装" class="headerlink" title="1.2 picgo的安装"></a>1.2 picgo的安装</h3><p><strong>文件—&gt;偏好的设置—&gt;图像—&gt;上传服务 PicGo-Core（command line）</strong></p>
<p><img src="https://img.daitcc.top:8090/i/2023/11/6558fbf716d57.png" alt="image-20231118233605962" loading="lazy"></p>
<h3 id="1-3-获取lsky的信息"><a href="#1-3-获取lsky的信息" class="headerlink" title="1.3 获取lsky的信息"></a>1.3 获取lsky的信息</h3><ul>
<li>使用 cURL(<strong>推荐</strong>)获取认证 token 信息</li>
</ul>
<pre class="language-bash" data-language="bash"><code class="language-bash">curl -X POST -F &quot;email&#x3D;354769733@qq.com&quot; -F &quot;password&#x3D;wsj123wsj&quot; https:&#x2F;&#x2F;img.daitcc.top:8090&#x2F;api&#x2F;v1&#x2F;tokens</code></pre>

<blockquote>
<p>提示：</p>
<p>此命令仅适用于 V2，V1 用户只需要进入个人设置页面复制、粘贴使用即可。</p>
</blockquote>
<ul>
<li>打开终端输入命令</li>
</ul>
<pre class="language-bash" data-language="bash"><code class="language-bash">C:\Users\35476\AppData\Roaming\Typora\picgo\win64&gt;curl -X POST -F &quot;email&#x3D;354769733@qq.com&quot; -F &quot;password&#x3D;wsj123wsj&quot; https:&#x2F;&#x2F;img.daitcc.top:8090&#x2F;api&#x2F;v1&#x2F;tokens
&#123;&quot;status&quot;:true,&quot;message&quot;:&quot;success&quot;,&quot;data&quot;:&#123;&quot;token&quot;:&quot;1|ykngSEREfC7uM2yID8liqidRImfZSwJDIpmLlQPx&quot;&#125;&#125;</code></pre>
<ul>
<li>保存获取的<code>认证token信息</code></li>
</ul>
<pre class="language-bash" data-language="bash"><code class="language-bash">Bearer 1|ykngSEREfC7uM2yID8liqidRImfZSwJDIpmLlQPx</code></pre>

<blockquote>
<p>提示：</p>
<p>通过设置请求 header 标头来验证请求(Bearer Token),所以<code>Bearer</code>不可少</p>
</blockquote>
<ul>
<li>使用cURL(<strong>推荐</strong>)获取默认上传的相册ID</li>
</ul>
<pre class="language-bash" data-language="bash"><code class="language-bash">curl -H &quot;Authorization:Bearer 1|ykngSEREfC7uM2yID8liqidRImfZSwJDIpmLlQPx&quot; -H &quot;Accept:application&#x2F;json&quot; https:&#x2F;&#x2F;img.daitcc.top:8090&#x2F;api&#x2F;v1&#x2F;albums</code></pre>

<blockquote>
<p>提示：</p>
<p>Authorization后面填刚保存的<code>认证token信息</code></p>
</blockquote>
<ul>
<li>打开终端输入命令</li>
</ul>
<pre class="language-bash" data-language="bash"><code class="language-bash">D:\Users\35476\Desktop&gt;curl -H &quot;Authorization:Bearer 1|ykngSEREfC7uM2yID8liqidRImfZSwJDIpmLlQPx&quot; -H &quot;Accept:application&#x2F;json&quot; https:&#x2F;&#x2F;img.daitcc.top:8090&#x2F;api&#x2F;v1&#x2F;albums
&#123;&quot;status&quot;:true,&quot;message&quot;:&quot;success&quot;,&quot;data&quot;:&#123;&quot;current_page&quot;:1,&quot;data&quot;:[&#123;&quot;id&quot;:3,&quot;name&quot;:&quot;\u65c5\u6e38&quot;,&quot;intro&quot;:&quot;&quot;,&quot;image_num&quot;:0&#125;,&#123;&quot;id&quot;:2,&quot;name&quot;:&quot;\u65e5\u5e38&quot;,&quot;intro&quot;:&quot;&quot;,&quot;image_num&quot;:0&#125;,&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;\u56fe\u5e8a&quot;,&quot;intro&quot;:&quot;&quot;,&quot;image_num&quot;:0&#125;],&quot;first_page_url&quot;:&quot;http:\&#x2F;\&#x2F;www.daitcc.top:8089\&#x2F;api\&#x2F;v1\&#x2F;albums?page&#x3D;1&quot;,&quot;from&quot;:1,&quot;last_page&quot;:1,&quot;last_page_url&quot;:&quot;http:\&#x2F;\&#x2F;www.daitcc.top:8089\&#x2F;api\&#x2F;v1\&#x2F;albums?page&#x3D;1&quot;,&quot;links&quot;:[&#123;&quot;url&quot;:null,&quot;label&quot;:&quot;&amp;laquo; \u4e0a\u4e00\u9875&quot;,&quot;active&quot;:false&#125;,&#123;&quot;url&quot;:&quot;http:\&#x2F;\&#x2F;www.daitcc.top:8089\&#x2F;api\&#x2F;v1\&#x2F;albums?page&#x3D;1&quot;,&quot;label&quot;:&quot;1&quot;,&quot;active&quot;:true&#125;,&#123;&quot;url&quot;:null,&quot;label&quot;:&quot;\u4e0b\u4e00\u9875 &amp;raquo;&quot;,&quot;active&quot;:false&#125;],&quot;next_page_url&quot;:null,&quot;path&quot;:&quot;http:\&#x2F;\&#x2F;www.daitcc.top:8089\&#x2F;api\&#x2F;v1\&#x2F;albums&quot;,&quot;per_page&quot;:40,&quot;prev_page_url&quot;:null,&quot;to&quot;:3,&quot;total&quot;:3&#125;&#125;</code></pre>

<p>将返回的参数整理之后可得</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml">&#123;
	&quot;status&quot;: true,
	&quot;message&quot;: &quot;success&quot;,
	&quot;data&quot;: &#123;
		&quot;current_page&quot;: 1,
		&quot;data&quot;: [
			&#123;
				&quot;id&quot;: 3,
				&quot;name&quot;: &quot;旅游&quot;,
				&quot;intro&quot;: &quot;&quot;,
				&quot;image_num&quot;: 0
			&#125;,
			&#123;
				&quot;id&quot;: 2,
				&quot;name&quot;: &quot;日常&quot;,
				&quot;intro&quot;: &quot;&quot;,
				&quot;image_num&quot;: 0
			&#125;,
			&#123;
				&quot;id&quot;: 1,
				&quot;name&quot;: &quot;图床&quot;,
				&quot;intro&quot;: &quot;&quot;,
				&quot;image_num&quot;: 0
			&#125;
		],
		&quot;first_page_url&quot;: &quot;https:&#x2F;&#x2F;img.daitcc.top:8090&#x2F;api&#x2F;v1&#x2F;albums?page&#x3D;1&quot;,
		&quot;from&quot;: 1,
		&quot;last_page&quot;: 1,
		&quot;last_page_url&quot;: &quot;https:&#x2F;&#x2F;img.daitcc.top:8090&#x2F;api&#x2F;v1&#x2F;albums?page&#x3D;1&quot;,
		&quot;links&quot;: [
			&#123;
				&quot;url&quot;: null,
				&quot;label&quot;: &quot;&amp;laquo; 上一页&quot;,
				&quot;active&quot;: false
			&#125;,
			&#123;
				&quot;url&quot;: &quot;https:&#x2F;&#x2F;img.daitcc.top:8090&#x2F;api&#x2F;v1&#x2F;albums?page&#x3D;1&quot;,
				&quot;label&quot;: &quot;1&quot;,
				&quot;active&quot;: true
			&#125;,
			&#123;
				&quot;url&quot;: null,
				&quot;label&quot;: &quot;下一页 &amp;raquo;&quot;,
				&quot;active&quot;: false
			&#125;
		],
		&quot;next_page_url&quot;: null,
		&quot;path&quot;: &quot;https:&#x2F;&#x2F;img.daitcc.top:8090&#x2F;api&#x2F;v1&#x2F;albums&quot;,
		&quot;per_page&quot;: 40,
		&quot;prev_page_url&quot;: null,
		&quot;to&quot;: 3,
		&quot;total&quot;: 3
	&#125;
&#125;</code></pre>

<blockquote>
<p>提示：</p>
<p>返回参数 data.data.name 相册名称 需要经过Unicode转中文</p>
<p>返回参数 data.data.id   相册自增 ID</p>
</blockquote>
<ul>
<li>保存获取的<code>相册ID</code></li>
</ul>
<pre class="language-BASH" data-language="BASH"><code class="language-BASH">图床 1
日常 2
旅游 3</code></pre>



<h2 id="2-修改lskypro源码可以指定默认上传相册"><a href="#2-修改lskypro源码可以指定默认上传相册" class="headerlink" title="2.修改lskypro源码可以指定默认上传相册"></a>2.修改lskypro源码可以指定默认上传相册</h2><ul>
<li>修改文件&#x2F;app&#x2F;Services&#x2F;ImageService.php第139行：</li>
</ul>
<p>原代码为：</p>
<pre class="language-php" data-language="php"><code class="language-php">&#x2F;&#x2F; 图片保存至默认相册(若有)
            if ($albumId &#x3D; $user-&gt;configs-&gt;get(UserConfigKey::DefaultAlbum)) &#123;
                if ($user-&gt;albums()-&gt;where(&#39;id&#39;, $albumId)-&gt;exists()) &#123;
                    $image-&gt;album_id &#x3D; $albumId;
                &#125;
            &#125;</code></pre>

<p>修改为：</p>
<pre class="language-php" data-language="php"><code class="language-php">if ($request-&gt;has(&#39;album_id&#39;)) &#123;
               $image-&gt;album_id &#x3D; $request-&gt;input(&#39;album_id&#39;);
           &#125; else &#123;
           &#x2F;&#x2F; 图片保存至默认相册(若有)
           if ($albumId &#x3D; $user-&gt;configs-&gt;get(UserConfigKey::DefaultAlbum)) &#123;
               if ($user-&gt;albums()-&gt;where(&#39;id&#39;, $albumId)-&gt;exists()) &#123;
                   $image-&gt;album_id &#x3D; $albumId;
               &#125;
           &#125;
       &#125;</code></pre>

<h2 id="3-安装lsky图床插件"><a href="#3-安装lsky图床插件" class="headerlink" title="3. 安装lsky图床插件"></a>3. 安装lsky图床插件</h2><ul>
<li><p>lsky图床插件</p>
<p><a href="https://www.npmjs.com/package/picgo-plugin-lankong?activeTab=readme">官方地址</a></p>
</li>
<li><p>安装方式<br>在对应系统的<code>PicGo</code>程序配置文件路径下执行 <code>npm i picgo-plugin-lankong</code>，然后重启应用即可。</p>
</li>
</ul>
<h2 id="4-修改配置文件"><a href="#4-修改配置文件" class="headerlink" title="4. 修改配置文件"></a>4. 修改配置文件</h2><p>这一步需要找到第1.2步中下载的<code>picgo</code>二进制文件，不同系统文件名略有不同：</p>
<ul>
<li><code>windows</code>系统一般在<code>C:\Users\用户名\AppData\Roaming\Typora\picgo\win64\</code>文件夹，文件名为<code>picgo.exe</code>；</li>
<li><code>linux</code>系统一般在<code>~/.config/Typora/picgo/linux/</code>文件夹，文件名为<code>picgo</code>；</li>
</ul>
<p><strong>接下来执行命令：</strong></p>
<ul>
<li><p><code>linux</code>系统，打开终端，在<code>home</code>目录下执行<code>./.config/Typora/picgo/linux/picgo install gitee-uploader</code>；</p>
</li>
<li><p><code>windows</code>系统，打开终端，可以在包含<code>picgo.exe</code>文件的路径下执行<code>.\picgo.exe install picgo-plugin-lankong</code>；</p>
</li>
</ul>
<p>在终端中打开你的<code>picgo.exe</code>路径，你可以通过<code>picgo -h</code>来查看所有命令：</p>
  <pre class="language-bash" data-language="bash"><code class="language-bash">$ picgo -h

  Usage: picgo [options] [command]

  Options:

    -v, --version                 output the version number
    -d, --debug                   debug mode
    -s, --silent                  silent mode
    -c, --config &lt;path&gt;           set config path
    -h, --help                    output usage information

  Commands:

    install|add [options] &lt;plugins...&gt;   install picgo plugin
    uninstall|rm &lt;plugins...&gt;            uninstall picgo plugin
    update [options] &lt;plugins...&gt;        update picgo plugin
    set|config &lt;module&gt; [name]           configure config of picgo modules
    upload|u [input...]                  upload, go go go
    use [module]                         use modules of picgo
    init [options] &lt;template&gt; [project]  create picgo plugin&#39;s development templates
    i18n [lang]                          change picgo language
    help [command]                       display help for command</code></pre>

<blockquote>
<p> <strong>提示</strong></p>
<p>其中，命令选项如果是用<code>&lt;&gt;</code>包围起来的为必须输入项，如果是用<code>[]</code>包围起来的则为可选输入项。 有些命令支持简写，比如<code>picgo upload</code>可以写为<code>picgo u</code>。</p>
</blockquote>
<p>使用<code>use</code>命令为<code>picgo</code>选择<code>lsky</code>图床</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">C:\Users\35476\AppData\Roaming\Typora\picgo\win64&gt;picgo use
? Use an uploader (Use arrow keys)
&gt; lankong
  smms
  tcyun
  github
  qiniu
  imgur
  aliyun
(Move up and down to reveal more choices)</code></pre>

<pre class="language-bash" data-language="bash"><code class="language-bash">C:\Users\35476\AppData\Roaming\Typora\picgo\win64&gt;picgo use
? Use an uploader lankong
? Use a transformer (Use arrow keys)
&gt; path
  base64</code></pre>

<pre class="language-bash" data-language="bash"><code class="language-bash">C:\Users\35476\AppData\Roaming\Typora\picgo\win64&gt;picgo use
? Use an uploader lankong
? Use a transformer path
? Use plugins (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)
&gt;(*) picgo-plugin-lankong</code></pre>

<pre class="language-bash" data-language="bash"><code class="language-bash">C:\Users\35476\AppData\Roaming\Typora\picgo\win64&gt;picgo use
? Use an uploader lankong
? Use a transformer path
? Use plugins (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)picgo-plugin-lankong
[PicGo SUCCESS]: Configure config successfully!</code></pre>

<p>picgo 需要配置文件来启动。当你未指定配置文件的时候，picgo 将会使用默认配置文件来启动。</p>
<h3 id="自动生成"><a href="#自动生成" class="headerlink" title="自动生成"></a>自动生成</h3><p><strong>通常来说你只需要配置 <code>Uploader</code> 即可，所以你可以通过 <code>picgo set uploader</code> 来进入交互式命令行，</strong></p>
<pre class="language-bash" data-language="bash"><code class="language-bash">C:\Users\35476\AppData\Roaming\Typora\picgo\win64&gt;picgo set uploader
? Choose a(n) uploader (Use arrow keys)
&gt; lankong
  smms
  tcyun
  github
  qiniu
  imgur
  aliyun
(Move up and down to reveal more choices)</code></pre>

<pre class="language-bash" data-language="bash"><code class="language-bash">C:\Users\35476\AppData\Roaming\Typora\picgo\win64&gt;picgo set uploader
? Choose a(n) uploader lankong
? Choose a version (Use arrow keys)
  V1
&gt; V2</code></pre>

<pre class="language-bash" data-language="bash"><code class="language-bash">C:\Users\35476\AppData\Roaming\Typora\picgo\win64&gt;picgo set uploader
? Choose a(n) uploader lankong
? Choose a version V2
? 示例: https:&#x2F;&#x2F;example.com https:&#x2F;&#x2F;img.daitcc.top:8090</code></pre>

<p>这里的<code>认证 token 信息</code>为第<code>1.3节</code>保存的token值</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">C:\Users\35476\AppData\Roaming\Typora\picgo\win64&gt;picgo set uploader
? Choose a(n) uploader lankong
? Choose a version V2
? 示例: https:&#x2F;&#x2F;example.com www.daitcc.top:8089
? 认证 token 信息 Bearer 1|ykngSEREfC7uM2yID8liqidRImfZSwJDIpmLlQPx</code></pre>

<p>这里<code>albumId</code>为第<code>1.3节</code>保存的<code>相册ID</code> (选择需要默认上传的 这里我选择的是 图床)</p>
<pre class="language-bash" data-language="bash"><code class="language-bash">C:\Users\35476\AppData\Roaming\Typora\picgo\win64&gt;picgo set uploader
? Choose a(n) uploader lankong
? Choose a version V2
? 示例: https:&#x2F;&#x2F;example.com www.daitcc.top:8089
? 认证 token 信息 Bearer 1|ykngSEREfC7uM2yID8liqidRImfZSwJDIpmLlQPx
? 选填, V1以及V2使用默认存储策略时请留空 1
? 选填, V2生效 1</code></pre>

<pre class="language-bash" data-language="bash"><code class="language-bash">C:\Users\35476\AppData\Roaming\Typora\picgo\win64&gt;picgo set uploader
? Choose a(n) uploader lankong
? Choose a version V2
? 示例: https:&#x2F;&#x2F;example.com www.daitcc.top:8089
? 认证 token 信息 Bearer 1|ykngSEREfC7uM2yID8liqidRImfZSwJDIpmLlQPx
? 选填, V1以及V2使用默认存储策略时请留空 1
? 选填, V2生效 1
? set permission private(default)
? 是否忽略证书错误, 如果上传失败提示证书过期请设为true No
? 是否同步删除, 只支持V2 No
[PicGo SUCCESS]: Configure config successfully</code></pre>

<h3 id="默认配置文件"><a href="#默认配置文件" class="headerlink" title="默认配置文件"></a>默认配置文件</h3><p>picgo 的默认配置文件为<code>~/.picgo/config.json</code>。其中<code>~</code>为用户目录。不同系统的用户目录不太一样。</p>
<p>linux 和 macOS 均为<code>~/.picgo/config.json</code>。</p>
<p>windows 则为<code>C:\Users\你的用户名\.picgo\config.json</code>。</p>
<p>可以用<code>写字板</code>打开</p>
<p>可以参考如下配置：</p>
<pre class="language-yaml" data-language="yaml"><code class="language-yaml">&#123;
  &quot;picBed&quot;: &#123;
    &quot;uploader&quot;: &quot;lankong&quot;,
    &quot;current&quot;: &quot;lankong&quot;,
    &quot;lankong&quot;: &#123;
      &quot;lskyProVersion&quot;: &quot;V2&quot;,
      &quot;server&quot;: &quot;https:&#x2F;&#x2F;img.daitcc.top:8090&quot;,
      &quot;token&quot;: &quot;Bearer 1|ykngSEREfC7uM2yID8liqidRImfZSwJDIpmLlQPx&quot;,
      &quot;strategyId&quot;: &quot;1&quot;,
      &quot;albumId&quot;: &quot;1&quot;,
      &quot;permission&quot;: 0,
      &quot;ignoreCertErr&quot;: false,
      &quot;syncDelete&quot;: false
    &#125;,
    &quot;transformer&quot;: &quot;path&quot;
  &#125;,
  &quot;picgoPlugins&quot;: &#123;
    &quot;picgo-plugin-lankong&quot;: true
  &#125;
&#125;</code></pre>

<h2 id="5-验证上传"><a href="#5-验证上传" class="headerlink" title="5.验证上传"></a>5.验证上传</h2><p><img src="https://img.daitcc.top:8090/i/2023/11/6558fbe5ea2c0.png" alt="image-20231119014836303" loading="lazy"></p>
<p><img src="https://img.daitcc.top:8090/i/2023/11/6558fbded18a3.png" alt="image-20231119015652256" loading="lazy"></p>
]]></content>
  </entry>
  <entry>
    <title>简单串口编写</title>
    <url>/posts/e1c9b379.html</url>
    <content><![CDATA[<h1 id="简单串口编写"><a href="#简单串口编写" class="headerlink" title="简单串口编写"></a>简单串口编写</h1><h2 id="1-ui-界面的创建"><a href="#1-ui-界面的创建" class="headerlink" title="1.ui 界面的创建"></a>1.ui 界面的创建</h2><p>打开<strong>Qt</strong>新建一个工程</p>
<img src="https://img.daitcc.top:8090/i/2023/11/655f5f775209e.png"/ loading="lazy">
<img src="https://img.daitcc.top:8090/i/2023/11/655f5f113052b.png"/ loading="lazy">
工程命名为 **QtSerial** ，选择路径时注意路径**不可出现中文名**。
<img src="https://img.daitcc.top:8090/i/2023/11/655f5f82894e9.png"/ loading="lazy">
这里选择默认，点击**下一步**
<img src="https://img.daitcc.top:8090/i/2023/11/655f5f87c2fec.png"/ loading="lazy">
这里基类选择 QWidget,修改类名为**MainWidget**，点击**下一步**
<img src="https://img.daitcc.top:8090/i/2023/11/655f5f8e5403e.png"/ loading="lazy">
这里选择默认，点击**下一步**
<img src="https://img.daitcc.top:8090/i/2023/11/655f5f92bac91.png"/ loading="lazy">
编译套件随便选择，后面可以随时进行更改，点击**下一步**
<img src="https://img.daitcc.top:8090/i/2023/11/655f5f96741cf.png"/ loading="lazy">
这里选择默认，点击**完成**
<img src="https://img.daitcc.top:8090/i/2023/11/655f5f9ade3a1.png"/ loading="lazy">

<p>进入工程，双击<strong>MainWidget.ui</strong>编辑ui文件（这里我们通过Qt的UI界面编辑器来设计ui界面，不以纯代码的形式来进行界面的设计。）<br><img src="https://img.daitcc.top:8090/i/2023/11/655f5f9f3ccfb.png"/ loading="lazy"><br>拖拽合适的控件完善布局。</p>
<ul>
<li>拖拽<strong>Tab Widget</strong>，并修改第 1 页为“<strong>串口助手</strong>”，第 2 页为“<strong>关于</strong>”<br><img src="https://img.daitcc.top:8090/i/2023/11/655f5fa4131d1.png" alt="image-20210923213127836" loading="lazy"></li>
<li>操作方法如下（动图展示）<br><img src="https://img.daitcc.top:8090/i/2023/11/655f5fabf1716.gif" alt="1" loading="lazy"></li>
</ul>
<p>完善其他控件的拖拽，完整 UI 文件可以到此处下载<a href="https://pan.baidu.com/s/1szEDoUIcotu8rehDhAvfvg" title="提取码：h7po">提取码：h7po</a>。</p>
<h3 id="最终界面展示图"><a href="#最终界面展示图" class="headerlink" title="最终界面展示图"></a>最终界面展示图</h3><p><img src="https://img.daitcc.top:8090/i/2023/11/655f5fb1617b0.png" alt="image-20211024114809591" loading="lazy"></p>
<h3 id="界面效果展示图-Windows-平台"><a href="#界面效果展示图-Windows-平台" class="headerlink" title="界面效果展示图(Windows 平台)"></a>界面效果展示图(Windows 平台)</h3><p><img src="https://img.daitcc.top:8090/i/2023/11/655f5fb621564.png" alt="image-20211024114925843" loading="lazy"></p>
<h2 id="2-QSerialPort模块介绍"><a href="#2-QSerialPort模块介绍" class="headerlink" title="2.QSerialPort模块介绍"></a>2.QSerialPort模块介绍</h2><h3 id="QT的QtSerialPort模块"><a href="#QT的QtSerialPort模块" class="headerlink" title="QT的QtSerialPort模块"></a>QT的QtSerialPort模块</h3><p>Qt中提供了两个C++类，分别是<strong>QSerialPort</strong> 和<strong>QSerialPortInfo</strong>。</p>
<p>它们功能如下：</p>
<p> <strong>QSerialPort</strong> ：提供了操作串口的各种接口。</p>
<p> <strong>QSerialPortInfo</strong> ：可以提供计算机中可用串口的各种信息。</p>
<h3 id="QtSerialPort模块使用方法"><a href="#QtSerialPort模块使用方法" class="headerlink" title="QtSerialPort模块使用方法"></a>QtSerialPort模块使用方法</h3><p> 首先，需要在pro文件中增加如下内容：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">QT +&#x3D; serialport    </code></pre>

<p>然后执行<strong>qmake</strong>，如果未执行 后面添加头文件时会报错。</p>
<p><img src="https://img.daitcc.top:8090/i/2023/11/655f5fbc38d92.png" alt="image-20211005013634387" loading="lazy"></p>
<p>给项目添加新的**C++**类，</p>
<img src="https://img.daitcc.top:8090/i/2023/11/655f5fc30d31d.png" alt="image-20211027145302605" style="zoom:50%; "  / loading="lazy">

<p>选择<strong>C++ Class</strong></p>
<p><img src="https://img.daitcc.top:8090/i/2023/11/655f5fc7861c4.png" loading="lazy"></p>
<p> 取名<strong>Serial</strong>，点击<strong>下一步</strong>即可生成对应的文件<img src="https://img.daitcc.top:8090/i/2023/11/655f5fcd4a622.png" alt="image-20211005014205307" loading="lazy"></p>
<p>在生成的<strong>serial.h</strong>中进行如下操作</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">#ifndef SERIAL_H
#define SERIAL_H

#include &lt;QObject&gt;
#include &lt;QSerialPort&gt;       &#x2F;&#x2F;添加串口类的头文件
#include &lt;QSerialPortInfo&gt;	 &#x2F;&#x2F;添加串口信息的头文件

class Serial : public QObject
&#123;
    Q_OBJECT
public:
    explicit Serial(QObject *parent &#x3D; nullptr);
    ~Serial(void);			&#x2F;&#x2F;添加析构函数
    void SerialOpen();		&#x2F;&#x2F;添加打开串口函数
    void SerialClose();		&#x2F;&#x2F;添加关闭串口函数
private:
    QSerialPort* MySerial;  &#x2F;&#x2F;添加串口类成员

signals:
    void SetInfo(QString info);
    void isnoSerialOpen();
&#125;;

#endif &#x2F;&#x2F; SERIAL_H

</code></pre>

<p>分别将光标置于函数后面 按下快捷键 <kbd>alt</kbd> + <kbd>enter</kbd> </p>
<pre class="language-c++" data-language="c++"><code class="language-c++">~Serial(void);			&#x2F;&#x2F;添加析构函数
void SerialOpen();		&#x2F;&#x2F;添加打开串口函数
void SerialClose();		&#x2F;&#x2F;添加关闭串口函数</code></pre>

<p>出现以下图片时 <strong>回车</strong> 即可在 <strong>cpp</strong> 文件中定义函数。<br><img src="https://img.daitcc.top:8090/i/2023/11/655f5fd1c94f8.png" alt="image-20211024112606270" loading="lazy"></p>
<p>动图展示。</p>
<p><img src="https://img.daitcc.top:8090/i/2023/11/655f5fd4b6502.gif" loading="lazy"></p>
<blockquote>
<p>~Serial(void);  用来<strong>delete</strong> 之后程序中 <strong>new</strong>出来的变量</p>
<p>void SerialOpen();和 void SerialClose();则是用来进行打开串口的操作。</p>
</blockquote>
<p>首先在 <strong>cpp</strong> 文件中 对<strong>MySerial</strong>进行实例化。</p>
<p><img src="https://img.daitcc.top:8090/i/2023/11/655f5fd9e1f61.png" alt="image-20211027151715679" loading="lazy"></p>
<p>然后，鼠标放在<strong>MySerial</strong>上按下快捷键<kbd>F1</kbd>,打开<strong>QSerialPort</strong>的帮助文档。找到<strong>Public Functions</strong></p>
<p><img src="https://img.daitcc.top:8090/i/2023/11/655f5fdf9558c.png" alt="image-20211027152623327" loading="lazy"></p>
<p>打开<strong>Detailed Description</strong><br><img src="https://img.daitcc.top:8090/i/2023/11/655f5fe45a532.png" alt="image-20211027153753566" loading="lazy"></p>
<p>从帮助文档中可以看出来，我们需要对串口进行的一些配置。</p>
<h3 id="配置串口参数"><a href="#配置串口参数" class="headerlink" title="配置串口参数"></a>配置串口参数</h3><p>操作步骤如下：</p>
<blockquote>
<p>1.首先需要设置要打开的串口名，这里可以通过**setPortName()<strong>或者</strong>setPort()**进行配置</p>
<p>2.然后通过使用open()函数以 read-only (r&#x2F;o), write-only (w&#x2F;o), or read-write (r&#x2F;w) 模式之一打开串口</p>
<p>3.然后，检测串口是否被打开 (且没有其他的进程或者线程打开串口，如果有就关闭串口在重新打开)</p>
<p>4.最后，配置串口参数如配置串口名，波特率，数据位，校验位，停止位和流控位</p>
</blockquote>
<p>配置函数如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">void setPortName(const QString &amp;name) 
bool setBaudRate(qint32 baudRate, QSerialPort::Directions directions &#x3D; AllDirections)
bool setDataBits(QSerialPort::DataBits dataBits)
bool setParity(QSerialPort::Parity parity)
bool setStopBits(QSerialPort::StopBits stopBits)
bool setFlowControl(QSerialPort::FlowControl flowControl)</code></pre>

<p>首先，我们需要<strong>QString</strong>和<strong>qint32</strong>这两个类型的<strong>name</strong>参数和<strong>baudRate</strong>参数，这是通过<strong>ui</strong>界面的<strong>Qcombobox</strong>选项得到的。因为使用<strong>多线程</strong>的原因，不能直接调用，所以，这里通过构建<strong>结构体</strong>，通过传递<strong>结构体</strong>来传递参数。</p>
<p>鼠标右键点击工程，添加一个新的<strong>cpp</strong>头文件</p>
<p><img src="https://img.daitcc.top:8090/i/2023/11/655f5fe8cca0f.png" loading="lazy"></p>
<p><img src="https://img.daitcc.top:8090/i/2023/11/655f5fedbbb21.png" alt="image-20211027193012335" loading="lazy"></p>
<p>设置头文件名称为 <strong>SerialInfo.h</strong> ，点击<strong>下一步</strong>，完成。</p>
<p><img src="https://img.daitcc.top:8090/i/2023/11/655f5ff1e403a.png" alt="image-20211027193154402" loading="lazy"></p>
<p>添加 <strong>SerialInfo.h</strong>的内容如下。</p>
<pre class="language-c" data-language="c"><code class="language-c">#ifndef SERIALINFO_H
#define SERIALINFO_H
#include &lt;QVector&gt;
#include &lt;QMetaType&gt;

typedef struct SerialInfos         &#x2F;&#x2F;串口配置信息
&#123;
     QString comName;    &#x2F;&#x2F;串口名称
     qint32 baudRate;     &#x2F;&#x2F;波特率
     qint32 dataBits;     &#x2F;&#x2F;数据位
     qint32 parity;       &#x2F;&#x2F;校验位
     qint32 stopBits;     &#x2F;&#x2F;停止位
     qint32 flowControl;  &#x2F;&#x2F;流控位
     qint32 Encode;       &#x2F;&#x2F;编码格式

&#125;Sinfo;


&#x2F;&#x2F;通过Q_DECLARE_METATYPE声明后，就可以让自定义的类型设置到QVariant。
Q_DECLARE_METATYPE(Sinfo);

#endif &#x2F;&#x2F; SERIALINFO_H
</code></pre>

<p>在<strong>serial.h</strong>中添加头文件 </p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">#include &quot;SerialInfo.h&quot;</code></pre>

<p><img src="https://img.daitcc.top:8090/i/2023/11/655f5ff6a6b1d.png" alt="image-20211027194025777" loading="lazy"></p>
<p>并添加私有成员</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">private:
    QSerialPort* MySerial;
    Sinfo *info&#x3D;nullptr;    &#x2F;&#x2F;串口配置
	QString InfoSet;        &#x2F;&#x2F;存储串口配置</code></pre>

<p><img src="https://img.daitcc.top:8090/i/2023/11/655f5ffa6976f.png" alt="image-20211027194229817" loading="lazy"></p>
<p>修改后的<strong>serial.h</strong>内容如下</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">#ifndef SERIAL_H
#define SERIAL_H

#include &lt;QObject&gt;
#include &lt;QSerialPort&gt;       &#x2F;&#x2F;添加串口类的头文件
#include &lt;QSerialPortInfo&gt;	 &#x2F;&#x2F;添加串口信息的头文件
#include &quot;SerialInfo.h&quot;

class Serial : public QObject
&#123;
    Q_OBJECT
public:
    explicit Serial(QObject *parent &#x3D; nullptr);
    ~Serial(void);			&#x2F;&#x2F;添加析构函数
    void SerialOpen();		&#x2F;&#x2F;添加打开串口函数
    void SerialClose();		&#x2F;&#x2F;添加关闭串口函数
private:
    QSerialPort* MySerial;  &#x2F;&#x2F;添加串口类成员
    Sinfo *info&#x3D;nullptr;    &#x2F;&#x2F;串口配置
    QString InfoSet;        &#x2F;&#x2F;存储串口配置
signals:
    void SetInfo(QString info); &#x2F;&#x2F;发送串口配置信号
    void isnoSerialOpen();	&#x2F;&#x2F;发送串口打开失败信号
&#125;;

#endif &#x2F;&#x2F; SERIAL_H
</code></pre>

<p>接下来在SerialOpen中操作。</p>
<p>首先判断串口是否打开，如果已经打开就关闭。这里调用SerialClose()（具体内容见下面SerialClose部分）</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">this-&gt;SerialClose();</code></pre>

<p>然后设置串口名</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">MySerial-&gt;setPortName(QString(info-&gt;comName));</code></pre>

<p>然后设置串口打开模式，R&#x2F;W模式，如果设置失败发送错误信息，然后返回。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">if(!MySerial-&gt;open(QIODevice::ReadWrite))&#x2F;&#x2F;用ReadWrite 的模式尝试打开串口
    &#123;
        emit isnoSerialOpen();  &#x2F;&#x2F;发送打开失败的标志
        return;
    &#125;</code></pre>

<blockquote>
<p>其中isnoSerialOpen()为设置的发送打开失败信号。</p>
</blockquote>
<p>然后设置波特率，波特率通过<strong>info-&gt;baudRate</strong>设置</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">MySerial-&gt;setBaudRate(qint32(info-&gt;baudRate));</code></pre>

<p>设置数据位，这里通过switch函数设置，其中setDataBits();中的参数通过使用<kbd>F1</kbd>查看，具体操作步骤如下。</p>
<p><img src="https://img.daitcc.top:8090/i/2023/11/655f60000f066.gif" loading="lazy"></p>
<p>使用同样的方法设置检验位、停止位和流控位。</p>
<p>在**SerialOpen()**中实现上述操作步骤，具体代码如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">void Serial::SerialOpen()
&#123;
    this-&gt;SerialClose();
    MySerial-&gt;setPortName(QString(info-&gt;comName));
    InfoSet&#x3D;QString::fromLocal8Bit(&quot;串口:&quot;); &#x2F;&#x2F;InfoSet存储串口设置信息，发送给mainWidget
    InfoSet.append(QString(info-&gt;comName));
    if(!MySerial-&gt;open(QIODevice::ReadWrite))&#x2F;&#x2F;用ReadWrite 的模式尝试打开串口
    &#123;
        emit isnoSerialOpen();  &#x2F;&#x2F;发送打开失败的标志
        return;
    &#125;
    &#x2F;&#x2F;设置波特率
    bool Bflag &#x3D; MySerial-&gt;setBaudRate(qint32(info-&gt;baudRate));
        if(Bflag)&#123;
            InfoSet.append(QString::fromLocal8Bit(&quot; 波特率:&quot;));
            &#x2F;&#x2F;第一个参数为int变量，第二个参数10表示转换为10进制数
            QString baudRateinfo &#x3D; QString::number(int(info-&gt;baudRate),10);
            InfoSet.append(baudRateinfo);
        &#125;
        else&#123;
            InfoSet.QString::fromLocal8Bit(&quot;波特率:Unknown&quot;);
        &#125;;
        &#x2F;&#x2F;设置数据位
        switch (info-&gt;dataBits) &#123;
                case 0:
                       MySerial-&gt;setDataBits(QSerialPort::Data5);
                       InfoSet.append(QString::fromLocal8Bit(&quot; 数据位:5&quot;));
                       break;
                case 1:
                       MySerial-&gt;setDataBits(QSerialPort::Data6);
                       InfoSet.append(QString::fromLocal8Bit(&quot; 数据位:6&quot;));
                       break;
                case 2:
                       MySerial-&gt;setDataBits(QSerialPort::Data7);
                       InfoSet.append(QString::fromLocal8Bit(&quot; 数据位:7&quot;));
                       break;
                case 3:
                       MySerial-&gt;setDataBits(QSerialPort::Data8);
                       InfoSet.append(QString::fromLocal8Bit(&quot; 数据位:8&quot;));
                       break;
                default:
                        MySerial-&gt;setDataBits(QSerialPort::UnknownDataBits);
                        InfoSet.append(QString::fromLocal8Bit(&quot; 数据位:Unknown&quot;));
                        break;
                &#125;
        &#x2F;&#x2F;设置校验位
        switch (info-&gt;parity) &#123;
                case 0:
                    MySerial-&gt;setParity(QSerialPort::EvenParity);
                    InfoSet.append(QString::fromLocal8Bit(&quot; 校验位:Even&quot;));
                    break;
                case 1:
                    MySerial-&gt;setParity(QSerialPort::MarkParity);
                    InfoSet.append(QString::fromLocal8Bit(&quot; 校验位:Mark&quot;));
                    break;
                case 2:
                    MySerial-&gt;setParity(QSerialPort::NoParity);
                    InfoSet.append(QString::fromLocal8Bit(&quot; 校验位:None&quot;));
                    break;
                case 3:
                    MySerial-&gt;setParity(QSerialPort::OddParity);
                    InfoSet.append(QString::fromLocal8Bit(&quot; 校验位:Odd&quot;));
                    break;
                case 4:
                    MySerial-&gt;setParity(QSerialPort::SpaceParity);
                    InfoSet.append(QString::fromLocal8Bit(&quot; 校验位:Space&quot;));
                    break;
                default:
                    MySerial-&gt;setParity(QSerialPort::UnknownParity);
                    InfoSet.append(QString::fromLocal8Bit(&quot; 校验位:Unknown&quot;));
                    break;
                &#125;
        &#x2F;&#x2F;设置停止位
        switch (info-&gt;stopBits) &#123;
                case 0:
                    MySerial-&gt;setStopBits(QSerialPort::OneStop);
                    InfoSet.append(QString::fromLocal8Bit(&quot; 停止位:1&quot;));
                    break;
                case 1:
                    MySerial-&gt;setStopBits(QSerialPort::OneAndHalfStop);
                    InfoSet.append(QString::fromLocal8Bit(&quot; 停止位:1.5&quot;));
                    break;
                case 2:
                    MySerial-&gt;setStopBits(QSerialPort::TwoStop);
                    InfoSet.append(QString::fromLocal8Bit(&quot; 停止位:2&quot;));
                    break;
                default:
                    MySerial-&gt;setStopBits(QSerialPort::UnknownStopBits);
                    InfoSet.append(QString::fromLocal8Bit(&quot; 停止位:Unknown&quot;));
                    break;
                &#125;
        &#x2F;&#x2F;设置流控位
        switch (info-&gt;flowControl) &#123;
                case 0:
                    MySerial-&gt;setFlowControl(QSerialPort::NoFlowControl);
                    InfoSet.append(QString::fromLocal8Bit(&quot; 流控位:None&quot;));
                    break;
                case 1:
                    MySerial-&gt;setFlowControl(QSerialPort::HardwareControl);
                    InfoSet.append(QString::fromLocal8Bit(&quot; 流控位:Hardware&quot;));
                    break;
                case 2:
                    MySerial-&gt;setFlowControl(QSerialPort::SoftwareControl);
                    InfoSet.append(QString::fromLocal8Bit(&quot; 流控位:Software&quot;));
                    break;
                default:
                    MySerial-&gt;setFlowControl(QSerialPort::UnknownFlowControl);
                    InfoSet.append(QString::fromLocal8Bit(&quot; 流控位:Unknown&quot;));
                    break;
                &#125;
        emit SetInfo(InfoSet);&#x2F;&#x2F;发送串口配置信号
&#125;</code></pre>

<p>添加**SerialClose()**函数。具体内容如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">void Serial::SerialClose()
&#123;
    if(MySerial-&gt;isOpen())&#x2F;&#x2F;如果串口已经打开了 先给他关闭了
    &#123;
        MySerial-&gt;clear();
        MySerial-&gt;close();
    &#125;
&#125;</code></pre>

<blockquote>
<p>添加接收串口配置参数函数。这个函数主要用从接收从ui界面处选择的串口参数，并保存在info中，前面提到了是通过结构体来传递参数的，因此构造函数时，要添加结构体的形参。</p>
</blockquote>
<p>在<strong>serial.h</strong>中添加公共函数*<em>void RecvSerialConfig(Sinfo <em>data);</em></em> 。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">public:
	void RecvSerialConfig(Sinfo *data);  &#x2F;&#x2F;接收串口配置参数函数</code></pre>

<p>按下<kbd>alt</kbd>+<kbd>enter</kbd>，在<strong>serial.cpp</strong>中添加定义。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">void Serial::RecvSerialConfig(Sinfo *data)
&#123;
    if(info!&#x3D;nullptr)   &#x2F;&#x2F;删除原先内存空间
    &#123;
        delete info;
    &#125;
    this-&gt;info &#x3D; new Sinfo;&#x2F;&#x2F;防止内存泄漏,关闭时 delete info;
    &#x2F;&#x2F;接收参数设置
    this-&gt;info-&gt;Encode&#x3D;data-&gt;Encode;
    this-&gt;info-&gt;baudRate&#x3D;data-&gt;baudRate;
    this-&gt;info-&gt;comName&#x3D;data-&gt;comName;
    this-&gt;info-&gt;dataBits&#x3D;data-&gt;dataBits;
    this-&gt;info-&gt;flowControl&#x3D;data-&gt;flowControl;
    this-&gt;info-&gt;parity&#x3D;data-&gt;parity;
    this-&gt;info-&gt;stopBits&#x3D;data-&gt;stopBits;
&#125;</code></pre>

<blockquote>
<p>这里要注意，申请内存空间时，结束后必须释放，不然容易导致内存泄漏。因此，需要在**~Serial(void);<strong>中添加</strong>delete info;**</p>
</blockquote>
<p>**~Serial(void);**函数如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">Serial::~Serial()
&#123;
    delete info;
&#125;</code></pre>

<h3 id="配置发送和接收函数"><a href="#配置发送和接收函数" class="headerlink" title="配置发送和接收函数"></a>配置发送和接收函数</h3><p>配置完打开和关闭函数后，这里要配置发送和接收函数</p>
<p>在<strong>serial.h</strong>中添加公共函数<strong>void SendData(QByteArray data, bool hexflag);</strong> 和<strong>void RecvData();<strong>。添加信号</strong>void isRecvData(QByteArray);</strong></p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">public:
    void SendData(QByteArray data, bool hexflag); &#x2F;&#x2F;发送数据
    void RecvData(); &#x2F;&#x2F;接收数据
signals:
    void isRecvData(QByteArray); &#x2F;&#x2F;接收数据信号</code></pre>

<p>按下<kbd>alt</kbd>+<kbd>enter</kbd>，在<strong>serial.cpp</strong>中添加定义。</p>
<blockquote>
<p>其中<strong>void SendData(QByteArray data, bool hexflag);</strong> 函数中，<strong>data</strong>为<strong>ui</strong>界面传递的数据，<strong>hexflag</strong>则为是否通过<strong>hex</strong>模式发送。</p>
<p><strong>isRecvData(QByteArray);<strong>则是向</strong>ui</strong>传递串口接收的数据。</p>
</blockquote>
<p>具体函数内容为：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">void Serial::SendData(QByteArray data, bool hexflag)
&#123;
    if(data.isEmpty())
    &#123;
        return;&#x2F;&#x2F;没有读取到数据就退出
    &#125;
    if(hexflag&#x3D;&#x3D;true)
    &#123;   &#x2F;&#x2F;hex模式直接发送
        MySerial-&gt;write(data);
    &#125;
    else&#123; &#x2F;&#x2F;判断编码格式在发送
         data&#x3D;SetCodeType(data,info-&gt;Encode); &#x2F;&#x2F;先根据编码转换数据编码格式
         MySerial-&gt;write(data);
    &#125;
&#125;

void Serial::RecvData()
&#123;
    QByteArray info &#x3D; MySerial-&gt;readAll();
    if(info.isEmpty())
     &#123;
       return ;&#x2F;&#x2F;没有读取到数据就退出
     &#125;
    emit isRecvData(info);
&#125;</code></pre>

<p>这里**SetCodeType();**函数为自己定义的设置数据编码格式函数。具体实现方式见 <strong>配置编码格式函数</strong> 。</p>
<h3 id="配置编码格式函数"><a href="#配置编码格式函数" class="headerlink" title="配置编码格式函数"></a>配置编码格式函数</h3><p>给项目添加新的<strong>C++<strong>类，右击</strong>工程</strong>，选择**ADD NEW …**。</p>
<p><img src="https://img.daitcc.top:8090/i/2023/11/655f5fe8cca0f.png" loading="lazy"></p>
<p>选择<strong>C++ Class</strong></p>
<p><img src="https://img.daitcc.top:8090/i/2023/11/655f5fc7861c4.png" loading="lazy"></p>
<p>按照如下图选择，点击<strong>下一步</strong>，<strong>完成</strong>。</p>
<p><img src="https://img.daitcc.top:8090/i/2023/11/655f600fd7459.png" loading="lazy"></p>
<p>修改<strong>codetype.h</strong>内容如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">#ifndef CODETYPE_H
#define CODETYPE_H

#include &lt;QString&gt;
#include &lt;QTextCodec&gt;

&#x2F;&#x2F;编码格式列表
typedef enum
&#123;
    ASCII &#x3D; 0,
    Utf8,     &#x2F;&#x2F;Utf8编码格式
    Utf16,    &#x2F;&#x2F;Utf16编码格式
    GBK,  &#x2F;&#x2F;GBK编码格式、兼容GBK18030、GB2312
    Big5,     &#x2F;&#x2F;Big5
    ShiftJIS
&#125;CodeType;
&#x2F;&#x2F;设置编码格式
QByteArray SetCodeType(QByteArray const &amp;data,qint32 control);
&#x2F;&#x2F;解析编码格式
QByteArray GetCodeType(QByteArray const &amp;data, qint32 control);
#endif &#x2F;&#x2F; CODETYPE_H
</code></pre>

<p>修改<strong>codetype.cpp</strong>内容如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">#include &quot;codetype.h&quot;
&#x2F;&#x2F;编码
QByteArray SetCodeType(const QByteArray &amp;data, qint32 control)
&#123;
    QByteArray tmpData;
    switch (control) &#123;
        case ASCII: tmpData&#x3D;QTextCodec::codecForName(&quot;latin1&quot;)-&gt;fromUnicode(data);break;
        case Utf8: tmpData&#x3D; QTextCodec::codecForName(&quot;UTF-8&quot;)-&gt;fromUnicode(data);break;
        case Utf16: tmpData&#x3D; QTextCodec::codecForName(&quot;UTF-16&quot;)-&gt;fromUnicode(data);break;
        case GBK: tmpData&#x3D; QTextCodec::codecForName(&quot;GBK&quot;)-&gt;fromUnicode(data);break;
        case Big5: tmpData&#x3D; QTextCodec::codecForName(&quot;Big5&quot;)-&gt;fromUnicode(data);break;
        case ShiftJIS: tmpData&#x3D; QTextCodec::codecForName(&quot;Shift-JIS&quot;)-&gt;fromUnicode(data);break;
        default:;break;
    &#125;
    return tmpData;
&#125;

&#x2F;&#x2F;解码
QByteArray GetCodeType(const QByteArray &amp;data, qint32 control)
&#123;
    QString tmpData;
    switch (control) &#123;
        case ASCII: tmpData&#x3D; QTextCodec::codecForName(&quot;latin1&quot;)-&gt;toUnicode(data);break;
        case Utf8: tmpData&#x3D; QTextCodec::codecForName(&quot;UTF-8&quot;)-&gt;toUnicode(data);break;
        case Utf16: tmpData&#x3D; QTextCodec::codecForName(&quot;UTF-16&quot;)-&gt;toUnicode(data);break;
        case GBK: tmpData&#x3D; QTextCodec::codecForName(&quot;GBK&quot;)-&gt;toUnicode(data);break;
        case Big5: tmpData&#x3D; QTextCodec::codecForName(&quot;Big5&quot;)-&gt;toUnicode(data);break;
        case ShiftJIS: tmpData&#x3D; QTextCodec::codecForName(&quot;Shift-JIS&quot;)-&gt;toUnicode(data);break;
        default:;break;
    &#125;
    return tmpData.toUtf8(); &#x2F;&#x2F;设置成Unicode格式
&#125;
</code></pre>

<blockquote>
<p>这里主要用到了QTextCodec这个类，具体内容可以看Qt的帮助文档，这里只简要概括。</p>
<blockquote>
<p> 1.需要包含**#include <QTextCodec>**这个头文件。</p>
<p> 2.QTextCodec 类主要是将数据用来在非 Unicode 格式和 Unicode 之间进行转换。</p>
</blockquote>
</blockquote>
<p>至此，QtSerialPort配置完成。</p>
<h2 id="3-线程类对象的添加和UI界面的参数设置"><a href="#3-线程类对象的添加和UI界面的参数设置" class="headerlink" title="3.线程类对象的添加和UI界面的参数设置"></a>3.线程类对象的添加和UI界面的参数设置</h2><h3 id="添加任务类对象和线程类对象"><a href="#添加任务类对象和线程类对象" class="headerlink" title="添加任务类对象和线程类对象"></a>添加任务类对象和线程类对象</h3><p>打开工程，选择<strong>mainwidget.h</strong>，添加我们创建的类<strong>Serial</strong>和线程类<strong>QThread</strong>。</p>
<p>内容如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">#ifndef MAINWIDGET_H
#define MAINWIDGET_H

#include &lt;QWidget&gt;
#include &quot;serial.h&quot;  &#x2F;&#x2F;添加自定义类serial头文件
#include &lt;QThread&gt;   &#x2F;&#x2F;添加线程类QThread头文件

QT_BEGIN_NAMESPACE
namespace Ui &#123; class MainWidget; &#125;
QT_END_NAMESPACE

class MainWidget : public QWidget
&#123;
    Q_OBJECT

public:
    MainWidget(QWidget *parent &#x3D; nullptr);
    ~MainWidget();
    QThread *t1;    &#x2F;&#x2F;1.创建子线程对象
    Serial *m_work; &#x2F;&#x2F;2.创建任务类对象
    
private:
    Ui::MainWidget *ui;

&#125;;
#endif &#x2F;&#x2F; MAINWIDGET_H
</code></pre>

<p>在<strong>mainwidget.cpp</strong>中将创建的对象实例化，并将任务函数移入子线程。</p>
<p>内容如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">#include &quot;mainwidget.h&quot;
#include &quot;ui_mainwidget.h&quot;

MainWidget::MainWidget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::MainWidget)
&#123;
    ui-&gt;setupUi(this);
    
    &#x2F;&#x2F;1.创建子线程对象，动态分配空间，指定父对象
    t1 &#x3D; new QThread(this);
    &#x2F;&#x2F;2.创建任务类对象,动态分配空间，不能指定父对象
    m_work &#x3D; new Serial;&#x2F;&#x2F;防止内存泄漏,关闭窗口时 delete m_work;
    &#x2F;&#x2F;3.将任务对象移动到某个子线程中
    m_work-&gt;moveToThread(t1);
    
&#125;

MainWidget::~MainWidget()
&#123;
    delete ui;
    delete m_work;  &#x2F;&#x2F;关闭时释放内存空间
&#125;</code></pre>

<blockquote>
<p>注：这里线程操作参考之前的文章<a href="https://blog.csdn.net/qq_39538318/article/details/120398160">Qt多线程的使用记录</a>中的方式二。</p>
</blockquote>
<h3 id="初始化ui界面参数"><a href="#初始化ui界面参数" class="headerlink" title="初始化ui界面参数"></a>初始化ui界面参数</h3><p>在开始工作前需要初始化ui界面的参数，如设置QCombobox的下拉框内容。因此需要创建一个<strong>void initUI(void)</strong>;函数。打开<strong>mainwidget.h</strong>，添加我们需要创建的函数，并使用快捷键<kbd>alt</kbd>+<kbd>enter</kbd>，在<strong>mainwidget.cpp</strong>中定义<strong>void initUI(void)</strong>;函数。</p>
<p>设置内容如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">public:
    MainWidget(QWidget *parent &#x3D; nullptr);
    ~MainWidget();
    QThread *t1;    &#x2F;&#x2F;1.创建子线程对象
    Serial *m_work; &#x2F;&#x2F;2.创建任务类对象
    void initUI();  &#x2F;&#x2F;初始化UI界面参数，如设置QCombobox的item和设置QSS样式。</code></pre>

<p>其中 <strong>void initUI();</strong> 函数内容如下。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">void MainWidget::initUI()
&#123;
     QStringList baudrateList; &#x2F;&#x2F;设置波特率列表
     baudrateList&lt;&lt;&quot;1200&quot;&lt;&lt;&quot;2400&quot;&lt;&lt;&quot;4800&quot;&lt;&lt;&quot;9600&quot;&lt;&lt;&quot;19200&quot;&lt;&lt;&quot;38400&quot;
                &lt;&lt;&quot;57600&quot;&lt;&lt;&quot;115200&quot;;
     ui-&gt;comBaudRate-&gt;addItems(baudrateList); &#x2F;&#x2F;将设置的Item加入到列表中
     ui-&gt;comBaudRate-&gt;setEditable(true); &#x2F;&#x2F;设置可以手动输入波特率
     &#x2F;&#x2F;限定波特率手动输入时只能输入数字且范围为(0, 1000000)即最高1M
     isBaudRateRange&#x3D; new QIntValidator; &#x2F;&#x2F;防止内存泄漏,关闭窗口时 delete aIntValidator;
     isBaudRateRange-&gt;setRange(0, 1000000);
     ui-&gt;comBaudRate-&gt;setValidator(isBaudRateRange);
     ui-&gt;comBaudRate-&gt;setCurrentIndex(3);  &#x2F;&#x2F;设置默认显示第4个即9600(从0开始)

     QStringList databitsList; &#x2F;&#x2F;设置数据位列表，根据串口中配置顺序设置。
     databitsList&lt;&lt;&quot;5&quot;&lt;&lt;&quot;6&quot;&lt;&lt;&quot;7&quot;&lt;&lt;&quot;8&quot;;
     ui-&gt;comDataBits-&gt;addItems(databitsList); &#x2F;&#x2F;将设置的Item加入到列表中
     ui-&gt;comDataBits-&gt;setCurrentIndex(3);  &#x2F;&#x2F;设置默认显示第4个即8bit(从0开始)

     QStringList parityList; &#x2F;&#x2F;设置校验位列表，根据串口中配置顺序设置。
     parityList&lt;&lt;&quot;Even&quot;&lt;&lt;&quot;Mark&quot;&lt;&lt;&quot;None&quot;&lt;&lt;&quot;Odd&quot;&lt;&lt;&quot;Space&quot;;
     ui-&gt;comParity-&gt;addItems(parityList); &#x2F;&#x2F;将设置的Item加入到列表中
     ui-&gt;comParity-&gt;setCurrentIndex(2);  &#x2F;&#x2F;设置默认显示第3个即None(从0开始)

     QStringList stopbitsList; &#x2F;&#x2F;设置停止位列表，根据串口中配置顺序设置。
     stopbitsList&lt;&lt;&quot;1&quot;&lt;&lt;&quot;1.5&quot;&lt;&lt;&quot;2&quot;;
     ui-&gt;comStopBits-&gt;addItems(stopbitsList); &#x2F;&#x2F;将设置的Item加入到列表中
     ui-&gt;comStopBits-&gt;setCurrentIndex(0);  &#x2F;&#x2F;设置默认显示第1个即1bit(从0开始)

     QStringList encodeList; &#x2F;&#x2F;设置编码格式列表，根据编码格式中配置顺序设置。
     encodeList&lt;&lt;&quot;ASCII&quot;&lt;&lt;&quot;UTF8&quot;&lt;&lt;&quot;UTF16&quot;&lt;&lt;&quot;GBK&quot;&lt;&lt;&quot;Big5&quot;&lt;&lt;&quot;ShiftJIS&quot;;
     ui-&gt;comEncode-&gt;addItems(encodeList); &#x2F;&#x2F;将设置的Item加入到列表中
     ui-&gt;comEncode-&gt;setCurrentIndex(0);  &#x2F;&#x2F;设置默认显示第1个即ASCII(从0开始)

&#125;</code></pre>

<blockquote>
<p>注：</p>
<ol>
<li>其中需要在<strong>mainwidget.h</strong>中添加   <strong>#include &lt; QStringList &gt;</strong> ;</li>
<li>配置的<strong>item</strong>参数需要同之前<strong>switch</strong>设置的参数顺序相同。</li>
<li>要在<strong>mainwidget.h</strong>中添加   <strong>#include &lt; QIntValidator &gt;</strong>;并创建一个私有成员，<em><em>QIntValidator</em> isBaudRateRange;</em>*</li>
</ol>
</blockquote>
<p>设置完成后在<strong>MainWidget</strong>中运行 <strong>initUI();</strong> 函数</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">MainWidget::MainWidget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::MainWidget)
&#123;
    ui-&gt;setupUi(this);

    &#x2F;&#x2F;0.初始化ui界面;
    initUI();
    &#x2F;&#x2F;1.创建子线程对象，动态分配空间，指定父对象
    t1 &#x3D; new QThread(this);
    &#x2F;&#x2F;2.创建任务类对象,动态分配空间，不能指定父对象
    m_work &#x3D; new Serial;&#x2F;&#x2F;防止内存泄漏,关闭窗口时 delete m_work;
    &#x2F;&#x2F;3.将任务对象移动到某个子线程中
    m_work-&gt;moveToThread(t1);

&#125;</code></pre>

<p>至此，<strong>QCombobox</strong> 参数初始化完成。(后期仍会在 <strong>initUI()</strong> 中进行其他配置如设置QSS样式等)。</p>
<h3 id="利用QSerialPortInfo得到串口号"><a href="#利用QSerialPortInfo得到串口号" class="headerlink" title="利用QSerialPortInfo得到串口号"></a>利用QSerialPortInfo得到串口号</h3><p>这里我们会发现并没有设置串口的<strong>Item</strong>参数。主要原因是，电脑再识别设备的串口号时，会任意分配可用的端口号，因此这里我们通过使用<strong>QSerialPortInfo</strong>类来得到可用端口号，并设置到串口的<strong>Item</strong>中。</p>
<p>首先，打开<strong>mainwidget.h</strong>，添加**#include <QSerialPortInfo >** , 然后创建 <strong>void getportInfo();</strong> 函数，并使用快捷键<kbd>alt</kbd>+<kbd>enter</kbd>，在<strong>mainwidget.cpp</strong> 中定义 <strong>void getportInfo();</strong> 函数。</p>
<p><strong>实现步骤：</strong></p>
<blockquote>
<p>首先检测可用的设备端口号，当存在可用的端口号时，通过遍历的方式，将可用的端口号保存在<strong>portStringList</strong>中。然后设置到串口的<strong>Item</strong>中。无可用端口号时，弹出信号框。</p>
</blockquote>
<p>具体内容如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">void MainWidget::getportInfo()
&#123;
    qint32 comCnt&#x3D;0; &#x2F;&#x2F;保存当前可用的串口数量
    QStringList portStringList; &#x2F;&#x2F;保存当前可用的串口列表

    if(portStringList.length()!&#x3D;0) 
    &#123;
      portStringList.clear();&#x2F;&#x2F;检测portStringList内容当不为空时清除再次调用时使用
    &#125; 
    if(ui-&gt;comPortName-&gt;count()!&#x3D;0)
    &#123;
        ui-&gt;comPortName-&gt;clear();&#x2F;&#x2F;检测comPortName的列表数量当不为空时清除再次调用时使用
    &#125;
    &#x2F;&#x2F;获取串口设备数量
    comCnt &#x3D; QSerialPortInfo::availablePorts().length();
    if(comCnt!&#x3D;0)
    &#123;
       &#x2F;&#x2F;获取串口信息
       foreach (const QSerialPortInfo &amp;qspinfo, QSerialPortInfo::availablePorts())
       &#123;
            portStringList+&#x3D;qspinfo.portName();
       &#125;
       ui-&gt;comPortName-&gt;addItems(portStringList);
    &#125;
    else&#123;   
        message(&quot;未检测到串口!&quot;);
        &#125;
&#125;</code></pre>

<blockquote>
<p>注：</p>
<ol>
<li>其中message();为自己重新封装的信号框函数，具体内容见下。</li>
</ol>
</blockquote>
<p>打开mainwidget.h，添加 #include &lt; QMessageBox &gt; , 然后重新封装函数 void message(const char <em>str); ，并使用快捷键<kbd>alt</kbd>+<kbd>enter</kbd>，在*<em>mainwidget.cpp</em></em> 中定义 void message(const char *str);函数。</p>
<p>具体内容如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">void MainWidget::message(const char *str)
&#123;
    QMessageBox msgBox;
    msgBox.setText(QString::fromLocal8Bit(str));
    msgBox.exec();
&#125;</code></pre>

<p>然后在<strong>MainWidget</strong>中运行 <strong>getportInfo();</strong> 函数</p>
<p>这里要注意,在拔插串口设备时，可用的端口号会产生变化，但 <strong>getportInfo();</strong> 函数仅在打开程序时运行一次，因此，这里需要增加更新端口号的方法。</p>
<p>实现方法：</p>
<blockquote>
<ol>
<li>添加检测拔插设备的函数，当设备变化时重新运行<strong>getportInfo();</strong></li>
<li>使用定时器，设定每100ms检测一次，当设备变化时重新运行<strong>getportInfo();</strong></li>
<li>增加按钮，当点击按钮时重新运行<strong>getportInfo();</strong></li>
</ol>
</blockquote>
<p>这里选择增加按钮的方法，主要原因是简单且不占用资源。</p>
<p><img src="https://img.daitcc.top:8090/i/2023/11/655f60192b5c5.png" alt="image-20211028233127314" loading="lazy"></p>
<p>增加按钮的信号与槽，当点击按钮时，重新运行<strong>getportInfo();</strong></p>
<p>具体内容如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">MainWidget::MainWidget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::MainWidget)
&#123;
    ui-&gt;setupUi(this);

    &#x2F;&#x2F;0.初始化ui界面;配置qss样式
    initUI();
    &#x2F;&#x2F;1.创建子线程对象，动态分配空间，指定父对象
    t1 &#x3D; new QThread(this);
    &#x2F;&#x2F;2.创建任务类对象,动态分配空间，不能指定父对象
    m_work &#x3D; new Serial;&#x2F;&#x2F;防止内存泄漏,关闭窗口时 delete m_work;
    &#x2F;&#x2F;3.将任务对象移动到某个子线程中
    m_work-&gt;moveToThread(t1);
    &#x2F;&#x2F;4.获取串口设备信息
    getportInfo();
        &#x2F;&#x2F;添加更新按钮信号与槽，用于更新串口设备信息
        connect(ui-&gt;upBtn,&amp;QPushButton::clicked,this,&amp;MainWidget::getportInfo);

&#125;</code></pre>

<p>至此，利用<strong>QSerialPortInfo</strong>得到串口号完成。</p>
<h2 id="4-配置UI界面的串口打开和关闭"><a href="#4-配置UI界面的串口打开和关闭" class="headerlink" title="4.配置UI界面的串口打开和关闭"></a>4.配置UI界面的串口打开和关闭</h2><h3 id="设置串口参数配置数组"><a href="#设置串口参数配置数组" class="headerlink" title="设置串口参数配置数组"></a>设置串口参数配置数组</h3><p>从之前的<strong>Serial</strong>配置可知，我们是通过配置<strong>ui</strong>界面的<strong>QCombobox</strong>来进行串口参数的配置的，因此想要配置的参数应用到<strong>Serial</strong>，需要设置结构体，通过信号与槽来传递结构体的值，来传递配置参数。</p>
<p>这里需要在<strong>mainwidget.h</strong>中添加**#include “SerialInfo.h”<strong>头文件，并添加一个私有成员</strong>info**。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">private:
    Ui::MainWidget *ui;
    QIntValidator* isBaudRateRange;&#x2F;&#x2F;设置波特率输入范围
    Sinfo *info&#x3D;nullptr; &#x2F;&#x2F;设置串口配置的参数</code></pre>

<blockquote>
<p>注：</p>
<ol>
<li>Sinfo *info可以见之前配置的内容。</li>
</ol>
</blockquote>
<p>在<strong>mainwidget.h</strong>中创建**void getComboBoxInfo();**用以获取配置参数。</p>
<p>具体内容如下:</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">void MainWidget::getComboBoxInfo()
&#123;
    if(info!&#x3D;nullptr)   &#x2F;&#x2F;删除原先内存空间
    &#123;
        delete info;
    &#125;
    this-&gt;info &#x3D; new Sinfo;&#x2F;&#x2F;防止内存泄漏,关闭窗口时 delete info;
    this-&gt;info-&gt;comName&#x3D;ui-&gt;comPortName-&gt;currentText();  &#x2F;&#x2F;设置串口号
    this-&gt;info-&gt;baudRate&#x3D;ui-&gt;comBaudRate-&gt;currentText().toInt();  &#x2F;&#x2F;设置波特率
    this-&gt;info-&gt;dataBits&#x3D;ui-&gt;comDataBits-&gt;currentIndex();  &#x2F;&#x2F;设置数据位
    this-&gt;info-&gt;parity&#x3D;ui-&gt;comParity-&gt;currentIndex();      &#x2F;&#x2F;设置检验位
    this-&gt;info-&gt;stopBits&#x3D;ui-&gt;comStopBits-&gt;currentIndex();  &#x2F;&#x2F;设置停止位
    this-&gt;info-&gt;flowControl&#x3D;0 ;                           &#x2F;&#x2F;设置流控位，默认值为0无流控
    this-&gt;info-&gt;Encode&#x3D;ui-&gt;comEncode-&gt;currentIndex();      &#x2F;&#x2F;设置编码格式
    
&#125;</code></pre>

<blockquote>
<p>注：</p>
<ol>
<li>其中，<strong>info</strong>在退出时要<strong>delete</strong>。</li>
</ol>
</blockquote>
<p>设置完参数时，记得放进<strong>MainWidget</strong>中执行。但MainWidget中之在打开程序时执行一次，因此，需要添加信号与槽来更新info的参数。由于使用的是<strong>QCombobox</strong>，查阅帮助文档可知，能用到的信号函数为**currentIndexChanged();**。</p>
<p><img src="https://img.daitcc.top:8090/i/2023/11/655f601e4ea99.gif" loading="lazy"></p>
<p>具体内容：</p>
<p><img src="https://img.daitcc.top:8090/i/2023/11/655f6023c6f7c.png" loading="lazy"></p>
<p>从截图中我们可以看出，当<strong>QCombobox</strong>的<strong>index</strong>变化时，可以返回两种参数：一种是当前所选变化的<strong>index</strong>值，另一种是当前所选变化的<strong>text</strong>的值。</p>
<p>因此可以在<strong>mainwidget.h</strong>中创建**void updataComboBox();**用以更新配置参数。</p>
<p>具体内容如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">void MainWidget::updataComboBox()
&#123;
    connect(ui-&gt;comPortName, QOverload&lt;const QString &amp;&gt;::of(&amp;QComboBox::currentIndexChanged),
        this,[&#x3D;](const QString &amp;text)&#123;
        &#x2F;* ... *&#x2F;
        this-&gt;info-&gt;comName&#x3D;text;  &#x2F;&#x2F;设置串口号
     &#125;);
    connect(ui-&gt;comBaudRate, QOverload&lt;const QString &amp;&gt;::of(&amp;QComboBox::currentIndexChanged),
        this,[&#x3D;](const QString &amp;text)&#123;
        &#x2F;* ... *&#x2F;
        this-&gt;info-&gt;baudRate&#x3D;text.toInt();  &#x2F;&#x2F;设置串口波特率
     &#125;);
    connect(ui-&gt;comDataBits, QOverload&lt;int&gt;::of(&amp;QComboBox::currentIndexChanged),
        this,[&#x3D;](int index)&#123;
        &#x2F;* ... *&#x2F;
        this-&gt;info-&gt;dataBits&#x3D;index;  &#x2F;&#x2F;设置串口数据位
     &#125;);
    connect(ui-&gt;comParity, QOverload&lt;int&gt;::of(&amp;QComboBox::currentIndexChanged),
        this,[&#x3D;](int index)&#123;
        &#x2F;* ... *&#x2F;
        this-&gt;info-&gt;parity&#x3D;index;  &#x2F;&#x2F;设置串口校验位
    &#125;);
    connect(ui-&gt;comStopBits, QOverload&lt;int&gt;::of(&amp;QComboBox::currentIndexChanged),
        this,[&#x3D;](int index)&#123;
        &#x2F;* ... *&#x2F;
        this-&gt;info-&gt;stopBits&#x3D;index;  &#x2F;&#x2F;设置串口停止位
    &#125;);
    connect(ui-&gt;comEncode, QOverload&lt;int&gt;::of(&amp;QComboBox::currentIndexChanged),
        this,[&#x3D;](int index)&#123;
        &#x2F;* ... *&#x2F;
        this-&gt;info-&gt;Encode&#x3D;index;  &#x2F;&#x2F;设置串口编码格式
    &#125;);
&#x2F;**预留流控控制**&#x2F;
&#x2F;&#x2F;    connect(ui-&gt;comFlowControl, QOverload&lt;int&gt;::of(&amp;QComboBox::currentIndexChanged),
&#x2F;&#x2F;        this,[&#x3D;](int index)&#123;
&#x2F;&#x2F;        &#x2F;* ... *&#x2F;
&#x2F;&#x2F;        this-&gt;info-&gt;flowControl&#x3D;index;  &#x2F;&#x2F;设置串口流控位
&#x2F;&#x2F;    &#125;);
&#125;</code></pre>

<p>至此，设置串口参数配置数组完成。</p>
<h3 id="设置打开串口和关闭串口按钮"><a href="#设置打开串口和关闭串口按钮" class="headerlink" title="设置打开串口和关闭串口按钮"></a>设置打开串口和关闭串口按钮</h3><p><img src="https://img.daitcc.top:8090/i/2023/11/655f60285cf0e.png" loading="lazy"></p>
<p>通过设置的ui界面可知，我们仅设置了一个按钮，因此想通过一个按钮去触发打开和关闭串口时就需要添加别的条件，这里可以使用两种解决方法。</p>
<blockquote>
<ol>
<li>设置按钮的文字，通过判断文字来判断当前所处的状态。（**setText()**函数）</li>
<li>设置按钮的状态，通过判断按钮状态来判断当前所处的状态。（**setChecked()**函数）</li>
</ol>
</blockquote>
<p>这里我们使用**setText()**的方法。</p>
<p>在<strong>mainwidget.h</strong>中创建**void SerialOpen();<strong>和</strong>void SerialClose();**用以打开和关闭串口。同时创建发送配置，打开和关闭串口信号。</p>
<p>内容如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">public:
    void SerialOpen();  &#x2F;&#x2F;打开串口函数
    void SerialClose(); &#x2F;&#x2F;关闭串口函数
signals:
    void SendSerialConfig(Sinfo *info);  &#x2F;&#x2F;发送串口配置信号
    void isCloseSerial();             &#x2F;&#x2F;发送关闭串口信号
    void isOpenSerial();              &#x2F;&#x2F;发送打开串口信号</code></pre>

<p>根据上述步骤，修改**SerialOpen();<strong>和</strong>SerialClose()**内容如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;打开串口设备
void MainWidget::SerialOpen(void)
&#123;
    &#x2F;&#x2F;设置串口打开按钮文本样式
     if(ui-&gt;OpenComBtn-&gt;text() &#x3D;&#x3D; QString::fromLocal8Bit(&quot;打开串口&quot;))&#123;
         ui-&gt;OpenComBtn-&gt;setText(QString::fromLocal8Bit(&quot;关闭串口&quot;));
         emit SendSerialConfig(info); &#x2F;&#x2F;发送串口配置信号
         emit isOpenSerial();
     &#125;
     else&#123;
         ui-&gt;OpenComBtn-&gt;setText(QString::fromLocal8Bit(&quot;打开串口&quot;));
         this-&gt;SerialClose();   &#x2F;&#x2F;执行关闭串口设备
     &#125;
&#125;
&#x2F;&#x2F;关闭串口设备
void MainWidget::SerialClose(void)
&#123;
    emit isCloseSerial();
&#125;</code></pre>

<p>设置完<strong>SerialOpen();<strong>和</strong>SerialClose()<strong>后，记得放进</strong>MainWidget</strong>中执行。</p>
<p>具体内容如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">MainWidget::MainWidget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::MainWidget)
&#123;
    ui-&gt;setupUi(this);

    &#x2F;&#x2F;0.初始化ui界面;配置qss样式
    initUI();
    &#x2F;&#x2F;1.创建子线程对象，动态分配空间，指定父对象
    t1 &#x3D; new QThread(this);
    &#x2F;&#x2F;2.创建任务类对象,动态分配空间，不能指定父对象
    m_work &#x3D; new Serial;&#x2F;&#x2F;防止内存泄漏,关闭窗口时 delete m_work;
    &#x2F;&#x2F;3.将任务对象移动到某个子线程中
    m_work-&gt;moveToThread(t1);
    &#x2F;&#x2F;4.获取串口设备信息
    getportInfo();
        &#x2F;&#x2F;添加更新按钮信号与槽，用于更新串口设备信息
        connect(ui-&gt;upBtn,&amp;QPushButton::clicked,this,&amp;MainWidget::getportInfo);
    &#x2F;&#x2F;5.获取串口参数配置数组
    getComboBoxInfo();
       &#x2F;&#x2F;添加串口参数数组的信号与槽，用于更新串口参数配置数组
       updataComboBox();
    &#x2F;&#x2F;6.打开线程并运行m_work的SerialOpen()和SerialClose()
    connect(ui-&gt;OpenComBtn,&amp;QPushButton::clicked,this,[&#x3D;]&#123;
            this-&gt;SerialOpen();
            t1-&gt;start();
        &#125;);
        qRegisterMetaType&lt;Sinfo&gt;(&quot;Sinfo&quot;);
        &#x2F;&#x2F;添加传递串口参数配置的信号与槽，用于传递串口参数配置
        connect(this,&amp;MainWidget::SendSerialConfig,m_work,&amp;Serial::RecvSerialConfig);
        &#x2F;&#x2F;添加打开串口的信号与槽，用于打开串口
        connect(this,&amp;MainWidget::isOpenSerial,m_work,&amp;Serial::SerialOpen);
        &#x2F;&#x2F;添加串口打开失败标志
        connect(m_work,&amp;Serial::isnoSerialOpen,this,[&#x3D;]()&#123;
            message(&quot;串口不存在，或被占用!&quot;);
            ui-&gt;OpenComBtn-&gt;setText(QString::fromLocal8Bit(&quot;打开串口&quot;));
        &#125;);
        &#x2F;&#x2F;添加关闭串口的信号与槽，用于释放串口
        connect(this,&amp;MainWidget::isCloseSerial,m_work,&amp;Serial::SerialClose);

&#125;</code></pre>

<blockquote>
<p>注：</p>
<ol>
<li>传递串口参数结构体时，需要先声明。</li>
</ol>
</blockquote>
<p>设置打开串口后，更新串口信息在ui界面上。</p>
<p>添加相应的信号与槽，具体内容如下</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;7.从m_work处传递回来的Serialinfo显示在ui界面上
connect(m_work,&amp;Serial::SetInfo,this,[&#x3D;](QString info)&#123;
    ui-&gt;Info-&gt;setText(info);
&#125;);</code></pre>

<p>设置成功后，添加当串口关闭时，清除INFO的内容。因此需要在**SerialClose()**中添加以下内容。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">&#x2F;&#x2F;关闭串口设备
void MainWidget::SerialClose(void)
&#123;
    ui-&gt;Info-&gt;clear();  &#x2F;&#x2F;清空显示的配置参数
    emit isCloseSerial(); &#x2F;&#x2F;发送关闭串口信号
&#125;</code></pre>

<p>至此，设置打开串口和关闭串口按钮完成。</p>
]]></content>
  </entry>
</search>
